## 进程和线程

对于操作系统来说，一个任务就是一个进程，有些进程不止同时干一件事，即同时运行多个“子任务”，这些子任务就是线程（进程中的一个执行任务，线程之间可以共享数据 ）。

根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位

资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（`PC`），线程之间切换的开销小。

包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的

影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行

## HTTP 1.0 2.0 3.0

### HTTP1.1

长连接：`HTTP1.0`需要使用`keep-alive`参数告知服务器端要建立一个长连接，`HTTP1.1`默认支持长连接。

> 在`http1.0`的时候，每次`http`请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应的时间，就需要重用连接。在`http1.1`的时候在`http`请求头中加入了`connection：keep-alive`来告诉对方这个请求响应完成后不要关闭，以此保持长连接。
>
> 优点：较少的`cpu`和内存的使用；允许请求和应答的`http`管线化；降低了拥塞控制；减少后续请求的延迟

节约带宽：`HTTP1.1`支持只发送`header`信息，如果服务器认为客户端有权限请求服务器，就返回100，否则返回401，接收到100的时候才开始把请求`body`发送到服务器，当为401就不发送请求`body`，节约带宽。

`HTTP1.1`还支持传送内容的一部分，这是断点续传的基础。

`HOST`域：`HTTP1.1`中`web server`上的多个虚拟站点可以共享同一个`ip`和端口。

### HTTP2

**头部压缩（只发送差异数据）**

`HTTP1`会在请求和响应的时候重复的携带不常改变的、冗长的头部数据，给网络带来额外负担。`HTTP2`会在客户端和服务器端使用”首部表“跟踪和存储发送的键值对，对于相同的数据，不在通过每次请求和响应发送。

首部表在`HTTP2`的连接存续期内始终存在，由客户端和服务器共同渐进地更新。

每个新首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。

**服务器推送**

服务端可以主动推送其他资源给客户端，比如`js`文件和`css`文件，不需要等到解析到`html`的时候在发送这些资源。当然客户端也有权利选择是否接收，如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送`RST_STREAM`帧来拒收，主动推送遵守同源策略，服务器不会随便推送第三方资源给客户端。

**多路复用**

`http1`想并发多个请求，必须使用多个`TCP`连接，同时会受到最大数量请求限制；

在`http2`中，同域名下所有通信都在单个连接上完成；单个连接可以承载任意数量的双向数据流；数据流以消息的形式发送，而消息又由一个或者多个帧组成，多个帧可以乱序发送，因为根据帧首部的流标识可以重新组装。

### HTTP3.0

因为`HTTP2`使用了多路复用，一般来说同一域名下只需要使用一个`TCP`连接。由于多个数据流使用同一个`TCP`连接，遵守同一个流量控制和拥塞控制。 只要一个数据流遭遇到拥塞，剩下的数据流就没法发出去，这样就导致了后面的所有数据都会被阻塞。`HTTP2` 出现的这个问题是由于其使用`TCP`协议的问题，与它本身的实现其实并没有多大关系。

由于 `TCP `本身存在的一些限制，`Google` 就开发了一个基于 `UDP` 协议的 `QUIC` 协议，并且使用在了`HTTP3` 上。 `QUIC`协议在 `UDP` 协议上实现了多路复用、有序交付、重传等等功能。

## HTTP请求方法

`get：`请求服务器发送某些资源

`head：`请求资源的头部信息，用来在下载一个大文件之前先获取大小再决定是否要下载

`options：`获取目的资源所支持的通信选项

`post：`发送数据给服务器

`put：`新增资源或者使用请求中的有效负载替换目标资源的表现形式（更新资源）

`delete：`删除资源

`patch：`对资源进行部分修改

`connect：`预留给能够将连接改为管道方式的代理服务器

`trace：`回显服务器收到的请求，用于测试或者诊断

### **`get`和`post`**

传输方式：`get`通过`url`传输数据，`post`通过请求体传输。

安全性：`post`更安全，`get`的数据在`url`中，可以通过历史记录和缓存查到，不安全

数据类型：`get`只允许`ASCII`字符，`post`无限制

`get`无害性：浏览器操作`get`请求是无害的，`post`可能重复提交表单

特性：`get`不会引起服务器状态变化（安全）且幂等，`post`是非安全非幂等

### **`post`和`put`**：

`put`：幂等，连续调用多次效果一样，以最新的一次调用为准，`post`是非幂等的 

`put`指向单一资源，`post`指向资源集合，用来新增。

**`put`和`patch`**：都是更新资源，`patch`用来对已知资源进行局部更新

### HTTP状态码

200 `OK`,表示从客户端发来的请求在服务器端被正确的处理

302 `found`,临时性重定向，表示资源临时被分配了新的`url`

304 `not modified`，上次请求之后请求的资源未被修改

400 `bad request` 请求报文存在语法错误

401 `unauthorized` 表示发送的请求需要有通过`HTTP`认证的认证信息

403 `forbidden` 对请求资源的访问被服务器拒绝（`token`过期、爬虫没有权限）

404 `not found` 在服务器上没找到请求的资源

500 `internal sever error` 服务器端在执行请求的时候发生了错误

### 307 303 302区别

在http1.1的时候为了细化302 分为了303和307

303明确表示客户端应当采用`get`方法获取资源，他会把`post`请求变为`get`进行重定向，307会遵守标准

## HTTP安全性

安全传输可以使用`HTTPS`,`HTTPS`基于`HTTP`协议，不过采用了`SSL`（安全套接层）协议或者`TLS`（安全层传输协议）对`HTTP`协议传输的数据进行加密，还提供了一种校验机制，信息一旦被篡改，通信双方就会立刻发现。

**对称加密**：双方使用同一把密钥对信息进行加密和解密；

优缺点：简单，性能好，但是容易被拦截密钥从而导致信息泄露

**非对称加密**：密钥对：私钥+公钥

通信双方都有自己的密钥对，可以把公钥公布出去，任何想和自己通信的，通过公钥加密，自己便可以通过私钥解密获取信息。

优缺点：安全性高，性能较弱。

**对称加密和非对称加密结合的方式**：将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密，之后就可以通过对称加密进行沟通。

优缺点：我们没有办法确定我们得到的公钥就⼀定是安全的公钥。可能存在⼀个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而我们自己还不知道。

**数字证书**：用来证明身份，防止被中间人攻击。证书中包括签发者，证书用途，使用者公钥，使用者私钥，使用者的hash算法，证书到期时间等。

**数字签名**：我们使用hash算法对公钥和一些信息进行加密，生成信息摘要，然后CA用私钥对摘要进行加密形成签名。接着将原始信息（即公钥和一些信息）和签名合在一起作为数字证书发送，接收方收到数字证书后对原始信息使用一样的hash算法生成摘要，使用公证处的公钥解密数字证书中的签名得到摘要，对比两个摘要就能判断是不是被修改

## XSS攻击

跨站脚本攻击（`Cross-site scripting`，`XSS`）是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。当被攻击者登陆网站时就会自动运行这些恶意代码，从而，攻击者可以突破网站的访问权限，冒充受害者。

如果 `Web` 应用程序没有部署足够的安全验证，那么，这些攻击很容易成功。浏览器无法探测到这些恶意脚本是不可信的，所以，这些脚本可以任意读取 `cookie`，`session` `tokens`，或者其它敏感的网站信息，或者让恶意脚本重写`HTML`内容。

**影响：**

1.利用虚假输入表单骗取用户个人信息

2.利用脚本窃取`Cookie`值，被害者在不知情的情况下帮助攻击者发送恶意的请求

3.显示伪造的文章和图片

**可分为：**存储型（持久型）、反射型（非持久型）、`DOM` 型

- 存储型：常见于带有用户保存数据的网站功能
- 反射性：存储型 `XSS` 的恶意代码存在数据库里，反射型 `XSS` 的恶意代码存在 `URL` 里，常见于通过 `URL` 传递参数的功能，如网站搜索、跳转等。需要用户主动打开恶意的 `URL` 才能生效
- `DOM`型：取出和执行恶意代码由浏览器端完成，属于前端 `JavaScript` 自身的安全漏洞，而其他两种 `XSS` 都属于服务端的安全漏洞。

**解决方案：**

预防存储型和反射型

- 改成纯前端渲染，把代码和数据分隔开。

纯前端渲染还需注意避免 `DOM` 型 `XSS` 漏洞

- 对 `HTML` 做充分转义。

对 `HTML`模板各处插入点进行充分的转义

预防`DOM`型`XSS`攻击

在使用 `.innerHTML`、`.outerHTML`、`document.write()` 时要特别小心，不要把不可信的数据作为 `HTML` 插到页面上，而应尽量使用 `.textContent`、`.setAttribute()` 等。

### [跨站请求伪造`CSRF`](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)

攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

**常见的攻击类型**

`get` `post` 链接类型

**特点**

- 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。

- 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。

- 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。

- 跨站请求可以用各种方式：图片`URL`、超链接、`CORS`、`form`提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

**防护策略**

- 阻止不明外域的访问
  - 同源检测

在`HTTP`协议中，每一个异步请求都会携带两个`header`，用于标记来源域名：

- `origin header`

- `referer header`

这两个`header`在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个`header`中的域名，确定请求的来源域。

- 提交时要求附加本域才能获取的信息
  - `CSRF Token`

1. 将`CSRF Token`输出到页面中

2. 页面提交的请求携带这个`Token`

3. 服务器验证`Token`是否正确

- 双重`Cookie`验证

要求`Ajax`和表单请求携带一个`Cookie`中的值。

在用户访问网站页面时，向请求域名注入一个`Cookie`，内容为随机字符串（例如`csrfcookie=v8g9e4ksfhw`）。

在前端向后端发起请求时，取出`Cookie`，并添加到`URL`的参数中（接上例`POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw`）。

后端接口验证`Cookie`中的字段与`URL`参数中的字段是否一致，不一致则拒绝。

为了从源头上解决这个问题，`Google`起草了一份草案来改进`HTTP`协议，那就是为`Set-Cookie`响应头新增`Samesite`属性，它用来标明这个 `Cookie`是个“同站 `Cookie`”，同站`Cookie`只能作为第一方`Cookie`，不能作为第三方`Cookie`，`Samesite` 有两个属性值，分别是 `Strict `和 `Lax`

`Samesite=Strict`

这种称为严格模式，表明这个 `Cookie` 在任何情况下都不可能作为第三方 `Cookie`

`Samesite=Lax`

这种称为宽松模式，比 `Strict` 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个`GET`请求，则这个`Cookie`可以作为第三方`Cookie`。

## 队首阻塞

队首阻塞：就是需要排队，队首的事情没有处理完的时候，后面的人都要等着。

### `http1.0`的队首阻塞

对于同⼀个`tcp`连接，所有的`http1.0`请求放入队列中，只有前⼀个请求的响应收到了，然后才能发送下⼀个请求。可见，`http1.0`的队首组塞发生在**客户端**。

### `http1.1`的队首阻塞

对于同一个`tcp`连接，`http1.1`允许一次发送多个`http1.1`请求，也就是说，不必等前一个响应收到，就可以发送下一个请求，这样就解决了`http1.0`的客户端的队首阻塞。但是，`http1.1`规定，服务器端的响应的发送要根据请求被接收的顺序排队，也就是说，先接收到的请求的响应也要先发送。这样造成的问题是，如果最先收到的请求的处理时间长的话，响应生成也慢，就会阻塞已经生成了的响应的发送。也会造成队首阻塞。可见，`http1.1`的队首阻塞发生在**服务器端**。

### `http2`是怎样解决队首阻塞的

`http2`无论在客户端还是在服务器端都不需要排队，在同一个`tcp`连接上，有多个`stream`，由各个`stream`发送和接收`http`请求，各个`steam`相互独立，互不阻塞。只要`tcp`没有人在用那么就可以发送已经生成的`request`或者`response`的数据，在两端都不用等，从而彻底解决了`http`协议层⾯的队首阻塞问题（但是`tcp`层仍存在问题）。

## `http`缓存，强缓存，协商缓存

浏览器缓存分为强缓存和协商缓存，当用户第一次请求资源的时候，会通过响应头决定缓存策略，当决定缓存资源的时候，将资源缓存在本地，在第二次请求资源的时候，根据`http` 请求头`header`判断是否命中强缓存，如果命中，从本地获取缓存，不会发送请求给服务器。

如果强缓存没有命中，客户端会发送请求给服务器， 服务器通过`request` 响应头`header`验证这个资源是否命中协商缓存，称为`http`再验证。如果命中，服务器将请求返回，返回304状态码，不返回资源，告诉客户端可以从本地获取，客户端收到返回后从缓存中读取资源。

共同点：如果命中了缓存 都不会返回资源，区别是强缓存不发请求，协商缓存会发送请求

当协商缓存也没有命中的话服务器就会返回资源

**强缓存**：`expires`：值是一个绝对时间格式的字符串，代表资源的过期时间，必须保证服务端时间和客户端时间严格一致；`cache-control：max-age`：判断缓存资源的最大生命周期，单位是秒，表示该资源多少时间后过期，解决了客户端和服务器时间必须同步的问题，因为是与客户端时间进行比较，优先级高。

`cache-Control：public`表示可以被所有用户缓存，包括终端和`CDN`等中间代理服务器

`cache-control：private`只能被终端浏览器缓存，不允许中继缓存服务器进行缓存；

`cache-control：no-cache`，跳过强缓存，强制进入协商策略。

`cache-control：no-store`，不会产生任何缓存

**协商缓存**：`last-modified`：资源最后更新时间，随服务器`response`返回

`if-modified-since`:客户端在发送请求的时候，将服务器返回的修改时间放在请求头`if-modified-since`发送给服务器，服务器再跟服务器上对应资源进行比较，来判断资源在两次请求期间是否有过修改，如果没有修改就命中协商缓存

`ETag`:资源内容的唯一标识（校验码），随服务器`response`返回，资源变化会导致`etag`变化

`if-none-match`:服务器通过比较这个和`etag`是否一致来判断资源是否被修改过，如果没有就命中协商缓存

`Last-modified`有一些缺陷：时间精确到秒一级，所以有些频繁改动无法确认，无法准确标注修改时间

有些固定周期的生成，内容不一定有变化，导致文件无法使用缓存。会优先使用`etag`

**区别：获取资源的时候是否会发送请求**

## `cookie` `sessionStorage`，`localStorage`

都可以用了来在浏览器端缓存数据，都是字符串类型的键值对，区别在于前两者属于`WebStorage`，创建他们的目的是便于客户端存储数据。

区别：

`cookie`数据始终在同源的`http`请求中携带（即使不需要），即`cookie`在浏览器和服务器间来回传递（可能会浪费带宽）。而`sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存。

`cookie`数据还有路径（`path`）的概念，可以限制`cookie`只属于某个路径下。

 存储大小限制也不同，`cookie`数据不能超过`4k`，同时因为每次`http`请求都会携带`cookie`，所以`cookie`只适合保存很小的数据，如会话标识。`sessionStorage`和`localStorage` 虽然也有存储大小的限制，但比`cookie`大得多，可以达到5M或更大。

数据有效期不同，`sessionStorage`：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；`localStorage`：始终有效，窗口或浏览器关闭也⼀直保存，因此用作持久数据；`cookie`只在设置的`cookie`过期时间之前⼀直有效，即使窗口或浏览器关闭。

 作用域不同，`sessionStorage`不在不同的浏览器窗口中共享，即使是同⼀个页面；

`localStorage` 在所有同源窗口中都是共享的；`cookie`也是在所有同源窗口中都是共享的。

`Web Storage` 支持事件通知机制，可以将数据更新的通知发送给监听者。 

`Web Storage` 的 `api` 接口使用更方便。

## [`cookie` `session`](https://www.jianshu.com/p/79225bd8a9c9)

## OSI7层模型

应用层(`HTTP`）、表示层(数据格式化)、会话层（建立解除会话）、传输层（提供端对端的接口）、网络层、数据链路层、物理层。

![七层模型](/assets/JS/七层模型.png)

![七层模型2](/assets/JS/七层模型2.png)

## HTTP和TCP的区别和联系

`tcp`是在传输层的协议，定义的是数据传输和连接方式的规范，`http`是应用层协议，定义的是传输数据的内容和规范，`HTTP`协议中的数据是利用`TCP`传输的，支持`HTTP`就一定支持`TCP`。

## [TCP和UDP](https://www.cnblogs.com/fundebug/p/differences-of-tcp-and-udp.html)

都是传输层的协议。

`TCP`使用校验和、确认和重传机制来保证可靠传输，使用滑动窗口机制实现流量控制，通过动态改变窗口的大小实现拥塞控制。

`TCP`是面向连接的，三次握手建立连接，四次挥手断开连接，基于字节流的传输层协议，因为有重传机制，所以可靠；因为通过`SYN`排序，所以有序，具有拥塞控制，但是传输速度慢；适合用来传输数据比较重要，不能丢失的情况，比如邮件系统

`UDP`面向无连接，只要端口号、目的地、源地址准确，就建立连接。丢包后数据会丢失所以不可靠；传输的数据是无序的，没有拥塞控制，传输速度较快

`TCP`向上层提供面向连接的可靠服务 ，`UDP`向上层提供无连接不可靠服务。

虽然 `UDP` 并没有 `TCP` 传输来的准确，但是也能在很多实时性要求高的地方有所作为

## TCP三次握手

`syn`是同步报文，`seq`是序列号，这是为了连接以后传送数据用的，`ack`是对收到的数据包的确认，值是等待接收的数据包的序列号。

 在第一次消息发送中，A随机选取一个序列号作为自己的初始序号（`seq`）发送给B，发送完毕后，客户端进入`syn_send`状态；第二次消息B使用`ack`对A的数据包进行确认，因为已经收到了序列号为x的数据包，准备接收序列号为`x+1`的包，所以`ack=x+1`，同时B告诉A自己的初始序列号，就是`seq=y`；`syn = 1`,`ACK = 1`(确认包)；发送完毕后，服务器端进入`syn_revd`状态；第三条消息A告诉B收到了B的确认消息并准备建立连接，A自己此条消息的序列号是`x+1`，所以`seq=x+1`，而`ack=y+1`是表示A正准备接收B序列号为`y+1`的数据包。

 `seq`是数据包本身的序列号；`ack`是期望对方继续发送的那个数据包的序列号。`syn`是同步序列编号。

![三次握手](/assets/JS/三次握手.png)

## TCP四次挥手

客户端或者服务器均可以主动发起挥手动作。

**第一次挥手（`FIN = 1`；`seq = x`）**

客户端发送一个`FIN`标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后客户端进入`fin_wait_1`状态；

**第二次挥手（`ACK=1`，`ACKnum = x+1`）**

服务器端确认客户端的`fin`包，发送一个确认包表明自己接收到了客户端关闭连接的请求，但是还没准备好关闭连接。

发送完毕后，服务器端进入`close_wait`状态，客户端接收到这个确认包之后，进入`fin_wait_2`状态等待服务器端关闭连接。

**第三次挥手（`FIN=1`,`seq=y`）**

服务器端准备好关闭连接时，向客户端发送结束连接请求，`FIN`值为1

发送完毕后，服务器端进入 `LAST_ACK` 状态，等待来自客户端的最后⼀个`ACK`。

**第四次挥手(`ACK=1`，`ACKnum=y+1`)**

客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 `TIME_WAIT` 状态，等待可能出现的要求重传的 `ACK` 包。

服务器端接收到这个确认包之后，关闭连接，进入`CLOSED`状态。

客户端等待了某个固定时间（两个最大段生命周期，`2MSL`，`2 Maximum Segment Lifetime`）之后，没有收到服务器端的`ACK`，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入`CLOSED`状态。

![四次挥手](/assets/JS/四次挥手.png)

## [TCP的拥塞控制机制](https://blog.csdn.net/qq_41431406/article/details/97926927)

### 定义

拥塞控制，就是在网络中发生拥塞时，减少向网络中发送数据的速度，防止造成恶性循环；同时在网络空闲时，提高发送数据的速度，最大限度地利用网络资源。

### 机制

假定数据单向传输，接收方的缓存足够大，这样拥塞程度就决定了发送方发送报文段多少。

以`tcp`报文段的**个数**为单位举例，发送方根据网络的拥塞程度动态改变一个拥塞窗口，发送窗口等于拥塞窗口，因此拥塞窗口决定了一次发送的报文个数。没有拥塞，拥塞窗口增加，拥塞了，拥塞窗口减少，是否拥塞的依据就是看确认报文是否按时收到。

### 慢开始（慢指的是一开始向网络中注入的报文段少）

`tcp`双方建立连接后，拥塞窗口设置为1（响应包14kb左右），之后每个传输轮次以指数形式增加拥塞窗口大小，然后设置一个慢开始门限，其实就是一个指数增长的上限。到达慢开始门限之后，改用拥塞避免算法。

### 拥塞避免（比较不容易拥塞，不是可以避免）

这个阶段是从慢开始门限开始，每个传输轮次之后，拥塞窗口线性加一，直到发生了超时重传，认为网络可能出现了拥塞，这个时候就将慢开始门限设置为发生拥塞的时候的拥塞窗口的一半，并且把拥塞窗口变为1，重新开始“慢开始-拥塞避免”这个过程。

![拥塞避免](/assets/JS/拥塞避免.png)

快重传和快恢复是改进`tcp`性能的新方法：个别报文段的丢失会被误认为拥塞，导致开始新的慢开始-拥塞避免，造成传输速率低。

### 快重传

使发送方尽快进行重传，而不是等待超时重传计时器超时了再重传。

接收方接收到数据的时候立即发送确认报文给发送方，即使接收方接收到失序的报文（意味着有报文丢失），也是立即发出对已经接受到的报文段的重复确认，确认的是丢失报文前那一个。发送方一旦收到连续的三个重复确认，就把重复确认的报文的下一个（丢失的那一个）进行重传。接收方收到后会返回针对最新的报文段（序号为最后的）的确认报文。

![快重传](/assets/JS/快重传.png)

因为接收到三个重复的确认，知道只是丢失了部分报文段而不是拥塞，执行快恢复算法。

### 快恢复

收到三个重复的确认的时候，把慢开始门限以及拥塞窗口的大小设置为当前快重传的窗口的一半，之后进行拥塞避免算法。

![快恢复](/assets/JS/快恢复.png)

## 浏览器渲染

### **1、导航**（`DNS`查找、`TCP`建立连接、`TLS`协商）

导航是加载`web`页面的第一步。它发生在以下情形：用户通过在地址栏输入一个`URL`、点击一个链接、提交表单或者是其他的行为（`web`性能优化的目标之一就是缩短导航完成所花费的时间，在理想情况下，它通常不会花费太多的时间，但是等待时间和带宽会导致它的延时。) 导航的第  一步是要去寻找页面资源的位置,浏览器通过服务器名称请求`DNS`进行查找，最终返回一个`IP`地址，第一次初始化请求之后，这个`IP`地址可能会被缓存一段时间，这样可以通过从缓存里面检索`IP`地址而不是再通过域名服务器进行查找来加速后续的请求(浏览器根据请求的`url`（统一资源定位符）交给`DNS`域名 解析，找到真实的`IP`，发送请求。这个过程会**先找缓存**，依次查找浏览器`DNS`缓存、操作系统`DNS`缓存、本地域名服务器，本地域名服务器采用递归查询、未找到向上级域名服务器进行迭代查询，先向根域名服务器发起请求，拿到顶级域名服务器地址，向顶级域名服务器发起请求拿到权限域名服务器地址，向权限域名服务器发起请求拿到`ip`地址返回给操作系统，并且缓存下域名和`ip`的映射关系，)获取到`IP`后，浏览器就会通过`TCP`”三次握手“与服务器建立连接。若在[`HTTPS`](https://segmentfault.com/a/1190000021494676)上建立安全连接（端口443），[`TLS`](https://segmentfault.com/a/1190000021559557?_ea=29659396)协商（表示层） ，它决定了什么密码将会被用来加密通信，验证服务器，在进行真实的数据传输之前建立安全连接。在发送真正的请求内容之前还需要三次往返服务器。

![url](/assets/JS/url.png)

![http加密](/assets/JS/http加密.png)

### **2、响应**（`TCP`慢开始、拥塞控制）：

一旦我们建立了到`web`服务器的连接，浏览器就代表用户发送一个初始的`HTTP GET`请求，对于网站来说，这个请求通常是一个`HTML`文件，第一块内容通常是`14kb`的数据。 一旦服务器收到请求，它将使用相关的响应头和`HTML`的内容进行回复。`**TCP慢开始**`：第一个响应包是`14kb`大小。这是慢开始的一部分，慢开始是一种均衡网络连接速度的算法。慢开始逐渐增加发送数据的数量直到达到网络的最大带宽。**拥塞控制：**当服务器用`TCP`包来发送数据时，客户端通过返回确认帧来确认传输。由于硬件和网络条件，连接的容量是有限的。 如果服务器太快地发送太多的包，它们可能会被丢弃。意味着，将不会有确认帧的返回。服务器把它们当做确认帧丢失。拥塞控制算法使用这个发送包和确认帧流来确定发送速率。

### **3、解析**（[构建`DOM`树](https://developer.mozilla.org/zh-CN/docs/Web/Performance/Critical_rendering_path)、预加载扫描器、构建`CSSOM`树）：

**“解析”**是浏览器将通过网络接收的数据转换为`DOM`和`CSSOM`的步骤，通过渲染器把`DOM`和`CSSOM`在屏幕上绘制成页面。**第一步是处理`HTML`标记**（`HTML`标记包括开始和结束标记，以及属性名和值。）**并构造`DOM`树**。`DOM`节点包含有关`HTML`元素的所有相关信息。 该信息是使用令牌描述的。 节点根据令牌层次结构连接到`DOM`树中。浏览器构建`DOM`树时，这个过程占用了主线程。当这种情况发生时，**预加载扫描仪**将解析可用的内容并请求高优先级资源，如`CSS`、`JavaScript`和`web`字体。不必等到解析器找到对外部资源的引用来请求它。

- > 老版本：阻塞 `DOM` 渲染

- > 新版本：虽然不会阻塞 `DOM` 渲染，但每一个图片请求都会占用一个 `HTTP`，而且 `Chrome` 最多允许对同一个 `Host` 同时建立六个 `TCP` 连接

**第二步是处理`CSS`并构建`CSSOM`树。**`CSSOM` 包含了页面所有的样式，也就是如何展示 `DOM` 的信息。`CSS` 是渲染阻塞的：浏览器会阻塞页面渲染直到它接收和执行了所有的 `CSS`。所以`CSS` 对象模型随着 `CSS` 的解析而被构建，但是直到完成之前都不能被用来构建渲染树，因为样式将会被之后的解析所覆盖而不应该被渲染到屏幕上。

### **4、渲染**（`style`、`layout`、`paint`、`compositing`）：

渲染步骤包括**样式、布局、绘制**，在某些情况下还包括**合成**。**第三步是将`DOM`和`CSSOM`组合成一个`Render`树**，计算样式树或渲染树从`DOM`树的根开始构建，遍历每个可见节点。**第四步是在渲染树上运行布局以计算每个节点的几何体。**布局是确定呈现树中所有节点的宽度、高度和位置，以及确定页面上每个对象的大小和位置的过程。回流是对页面的任何部分或整个文档的任何后续大小和位置的确定。**最后一步是将各个节点绘制到屏幕上**，第一次出现的节点称为[`first meaningful paint`](https://developer.mozilla.org/en-US/docs/Glossary/first_meaningful_paint)。当文档的各个部分以不同的层绘制，相互重叠时，必须进行**合成**，以确保它们以正确的顺序绘制到屏幕上，并正确显示内容。（渲染最耗时间）

## 浏览器缓存

浏览器对于所请求资源的缓存处理有一套完整的机制，主要包含以下三个策略：**存储策略、过期策略、协商策略**。

其中，**存储策略发生在收到请求响应后，用于决定是否缓存相应资源；过期策略发生在请求前，用于判断缓存是否过期；协商策略发生在请求中，用于判断缓存资源是否更新。**

浏览器在应用缓存策略时，具体的判断流程如下：

![缓存](/assets/JS/缓存.png)

### 资源更新，时间没过期

对于开发者：`ctrl+F5`，或者控制台 `network` `disable` `cache`

1.不要缓存`HTML`，避免缓存后用户无法及时获取到更新内容。

2.使用`Cache-Control`和`ETag`来控制`HTML`中所使用的静态资源的缓存。一般是将`Cache-Control`的`max-age`设成一个比较大的值，同时一些资源使用`catch-control`的`no cache`，然后用`ETag`进行验证。

3.使用签名或者版本来区分静态资源。这样静态资源会生成不同的资源访问链接，不会产生修改之后无法感知的情况。

### 缓存重新加载

`ctrl+F5` **硬性重新加载**，所有的资源（静态资源、`ajax`请求）都会从服务器重新再次请求，不会被浏览器所缓存。`CTRL+F5`触发的`HTTP`请求的请求头中没有上面的那两个头，却有`Pragma: no-cache` 或 `Cache-Control: no-cache` 字段，或者两者兼有。

`F5` **正常重新加载**，也就是说浏览器会缓存在内存或者磁盘当中。`F5`触发的`HTTP`请求的请求头中通常包含了`If-Modified-Since` 或 `If-None-Match`字段,或者两者兼有。

![缓存加载](/assets/JS/缓存加载.png)

`F5`刷新的`js`和`img`后面的`size`字段和之前的不一样了，变成了`from memory cache`

#### size 选项的 4 种情况

1.资源的大小

2.`from disk cache`

3.`from memory cache`

4.`from ServiceWorker`

###### `from disk cache`

 表示此资源是取自`磁盘`，不会请求服务器。已经在之前的某个时间加载过该资源，但是此资源不会随着该页面的关闭而释放掉，因为是存在硬盘当中的，下次打开仍会 `from disk cache`。

###### `from memory cache`

 表示此资源是取自`内存`，不会请求服务器。已经加载过该资源且缓存在内存当中；关闭该页面此资源就被内存释放掉了，再次打开相同页面时不会出现 `from memory cache` 的情况。

###### 资源本身大小数值

 当 http 状态为 200 是实实在在从浏览器获取的资源，当 http 状态为 304 时该数字是与服务端通信报文的大小，并不是该资源本身的大小，该资源是从本地获取的。

### `get`请求缓存问题

1.服务端处理，在`response`的 `header` 中添加`@{@"Cache-Control": @"no-cache, must-reva lidate"}`;

 2.客户端在`header`中添加`@{@"If-Modified-Since": @"0"}`

 3.客户端在`header`中添加`@{@"Cache-Control": @"no-cache"}`，

 4.客户端在`GET`请求的`url`中添加参数`@{@"timestamp": @([[NSDate date] timeIntervalSince1970]}`

 6.用`POST`替换`GET`请求

## 浏览器性能优化

- 优化网站速度
  - 启用`gzip`压缩：通过`npm i -S compression`等方式安装`compression`包，使用`app.use`(`compression()`)
  - 减少`HTTP`请求：通过`webpack`等打包工具对资源进行打包合并去重压缩。
  - 减少`DNS`查询：`DNS`缓存、将资源分布到恰当数量的主机上
  - 使用`CDN`：内容分发网络，可以缩短时延。用户和内容之间的物理距离缩短了，等待时间就减少了。`cdn`系统能够实时根据网络流量和各节点连接负载以及到用户的距离和响应时间等，将用户的请求重新导向离用户最近的服务节点上，保证资源的加载速度和稳定性。
- 运行时性能

运行时性能是页面运行（而不是加载）时的性能，可以从结构层、表现层和行为层进行分析。

**结构层：**指的是`DOM`结构，重点是减少`DOM`数量，减少`DOM`操作。

- 1.不同的`DOM`效率不一样，渲染较快的元素为轻元素。称`table`，`img`这样的元素为重元素。尽量避免重元素的出现，比如`table` 可以采用`ul` `li` 实现。
- 减少没必要的嵌套。

**表现层：**指的是`CSS`，可以从提高`CSS`的加载性能和提高`CSS`的代码性能考虑。

- 提高`CSS`的加载性能
  - `webpack`打包减少`CSS`文件的大小
  - 利用`http`缓存（从外部引入`js`和`css`：因为`JavaScript`和`CSS`文件都能在浏览器中产生缓存。内置在`HTML`文档中的`JavaScript` 和`CSS`则会在每次请求中随`HTML`文档重新下载。）
  - 合理运用继承属性减少代码（`color`、`font-size`、`font-family`等）
- 提高`CSS`代码性能
  - 减少复杂的嵌套样式
  - 网站的动画做到`16ms`（1000ms/60帧）以内；使用3D加速应用好`GPU`性能

**行为层：**指的是用户交互方面的内容，在前端主要通过`JS`实现。

- 计算缓存：一些复杂运算的结果进行缓存以供给下次使用
- 避免滥用闭包造成的内存泄漏

**图片优化：**

- 压缩图片体积：只下载需要缩略显示的部分，比如`imgix`（能够找到图片中有趣的区域并做裁剪。而不是仅仅裁剪出图片的中心）；
- [懒加载](https://www.cnblogs.com/liliangel/p/6122836.html)

先将`img`标签的`src`链接设为同一张图片（比如空白图片），然后给`img`标签设置自定义属性（比如 `data-src`）,然后将真正的图片地址存储在`data-src`中，当`JS`监听到该图片元素进入可视窗口时，将自定义属性中的地址存储到`src`属性中。达到懒加载的效果。

这样做能防止页面一次性向服务器发送大量请求，导致服务器响应面，页面卡顿崩溃等。

## 跨域

**同源策略：**

一个域下的`js`脚本未经允许不能访问另一个域的内容。协议、域名、端口都需要相同，否则不是一个域。

**主要限制三个方面：**

`js`脚本不能够访问其他域下的`cookie` `localStorage` `indexDB`

当前域下的`js`脚本不能操作访问其他域下的`DOM`

`ajax`无法发送跨域请求。

**同源政策目的：**

保证信息安全，只会限制`js`脚本。

**解决跨域：**

**使用`jsonp`** 来实现跨域请求，它的主要原理是通过动态构建 `script` 标签来实现跨域请求，因为**浏览器对`script` 标签的引入没有跨域的访问限制** 。通过在请求的 `url` 后指定⼀个回调函数，然后服务器在返回数据的时候，构建⼀个 `json` 数据的包装，这个包装就是回调函数，然后返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行，这样我们先前定义好的回调函数就可以被调用，从而实现了跨域请求的处理。这种方式只能用于`get`请求。

**使用`CORS`**的方式，`CORS` 是⼀个 `W3C `标准，全称是"跨域资源共享"。`CORS` 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，因此我们只需要在服务器端配置就行。浏览器将 `CORS` 请求分成两类：简单请求和非简单请求。对于简单请求，浏览器直接发出 `CORS` 请求。具体来说，就是会在头信息之中，增加⼀个 `Origin` 字段。`Origin` 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 `Origin` 指定的源，不在许可范围内，服务器会返回⼀个正常的 `HTTP` 回应。浏览器发现，这个回应的头信息没有包含`Access-Control-Allow-Origin` 字段，就知道出错了，从而抛出⼀个错误，`ajax` 不会收到响应信息`tcp`是在传输层的协议，定义的是数据传输和连接方式的规范，http是应用层协议，定义的是传输数据的内容和规范，`HTTP`协议中的数据是利用`TCP`传输的，支持`HTTP`就一定支持`TCP`。

**使用`nginx`**的方式，代理服务器，轻量级、启动快、高并发。所有客户端请求都必须先经过`nginx`处理，再将请求转发给`node`或者`java`，规避同源策略。

**使用`websocket`**

## CDN

`cdn`是内容分发网络，简单来说就是将内容缓存在用户附近的服务器上。通过更多的缓存服务点（`cdn`边缘节点）放在用户访问相对集中的地区或网络中，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户的内容。

![CDN](/assets\JS\CDN.png)

用户请求资源，`isp`根据`url`去查找本地`dns`系统寻求`IP`地址解析。本地`dns`系统会将解析权交给`cdn`专用的`dns`服务器。

`cdn`的专用`dns`服务器，将`cdn`的全局负载均衡设备`ip`地址返回给用户

用户访问全局负载均衡设备发请求，全局负载均衡设备根据`ip`选择一台用户所属区域的缓存服务器。并返回给用户这个服务器的`ip`地址，用户继续发送请求。缓存服务器响应请求，将用户所需的内容传到用户终端。

如果缓存服务器上没有用户想要的内容，这台缓存服务器就要到网站的源服务器请求内容。

源服务器返回内容给缓存服务器，缓存服务器发给用户，根据用户自定义的缓存策略，判断要不要把内容缓存到缓存服务器上。
