## `HTML5`新特性

增加了`header` `footer` `nav` `aside` `section`等语义化标签，在表单方面，为了增强表单，为`input`增加了`color` `email` `data` `range`等类型 在存储方面提供了`sessionStorage` `localStorage`和离线存储 在多媒体方面规定了音频和视频元素`audio`等。

## `HTML`编程的代码格式

文档类型声明位于`HTML`文档的第一行：

```HTML
<!doctype html> <!-- 文档类型声明 -->
<html>

<head>
<meta charset="utf-8"> <!-- 元数据 -->
<title>呵呵</title> <!-- 标题 -->
</head> 

<body> <!-- 网页控件元素，类似按钮/图片/文章什么的都写在这里 --> 
</body> 
</html>
```

`HTML5` 元素名可以使用大写和小写字母。推荐使用小写字母；属性名也是，属性值建议加上`“”`

你不一定要关闭所有元素 (例如 `<p> `元素)，但我们建议每个元素都要添加关闭标签。

## `meta`有什么，有哪些作用

`meta`是文档级元数据元素，有字符集声明、编译指示指令（其允许的值都是特定`http`头部的名称）、设置关键字，被用来给个大搜索引擎登录。

```HTML
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
```

1.定义文档的编码，便于浏览器解析

2.对`viewport`进行控制，让当前`viewport`的宽度等于设备的宽度，同时可以设置不允许手动缩放。如果不设定，会使得视图比屏幕宽，也就是说会出现横向滚动条。

## `CSS`选择器

### **分类**

分为`ID`选择器（`#id`）、类选择器（`.class`）、标签选择器（`p`）、通用选择器（`*`）、属性选择器（`[type="text"]`）、伪类选择器（`:hover`）、伪元素选择器（`::first-line`）、子选择器、相邻选择器（`:first-child`）

### **权重计算规则：**

`!important`

第一等：内联样式，如`style=""`，权值为1000；

第二等：代表`ID`选择器，如：`#content`，权值为100；

第三等：类选择器、伪类和属性选择器，如：`.content`，权值为10；

第四等：代表类型选择器和伪元素选择器，权值为1；

通配符、子选择器、相邻选择器没有权值

继承的样式没有权值

### **写法：**

并集选择器：选择器1,选择器2,......选择器n{}，多个选择器之间**逗号**分隔

生效规则：只要满足任何一个选择器，样式即可生效

交集选择器：选择器1选择器2......选择器n{}，多个选择器之间**紧挨**着，没有分隔

生效规则：多个选择器取交集，必须满足所有选择器的要求，样式才能生效。

后代选择器：选择器1 选择器2 ... 选择器n{}

生效规则：只要满足后一个选择器是前一个选择器的后代，样式即可生效

子代选择器：选择器1>选择器2>...选择器n{}

生效规则：必须满足后一个选择器是前一个选择器的**直接子代**，样式才能生效。

**伪类选择器：**

用于选择处于特定状态的元素，在标记文本中减少多余的类，使代码更灵活，更易于维护。

在选择器的后面，用分隔符:分隔，并紧接伪类状态，如`a:hover{}`

子元素选择器`:first-child` 匹配子元素选择器前那个父元素的第一个子元素是该元素的元素。

超链接的伪类状态：

`:link`-未访问状态

`:visited`-已访问状态

`:hover`-鼠标移到上面的状态

`:active`-激活选定状态

当超链接多种伪类状态共存时，必须按照`link-visited-hover-active`的顺序排列，否则会导致某些状态不能生效。

**伪元素选择器：**

加入全新的`html`元素一样。“生成内容”

`::before`（匹配出现在原有元素的实际内容之前的一个可样式化元素。）和`::after`（匹配出现在原有元素的实际内容之后的一个可样式化元素。），和`content`属性一起使用

将内容插入到文档中，更推荐的用法是插入图标，或者插入空字符串。

```HTML
.box::after{
    content: "图标样式"
}

<p class="box">Content in the box in my HTML page.</p>
```

**伪类和伪元素的区别：**

伪类用于当已有的元素处于某个状态的时候，为其添加对应的样式，这个状态是根据用户的行为动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过`:hover` 来描述这个元素的状态。

**伪元素用于创建一些不在文档树中的元素，并为其添加样式。**它们允许我们为元素的某些部分设置样式。比如说，我们可以通过`::before` 来在⼀个元素前增加⼀些文本，并为这些文本添加样式。虽然用户可以看到这些文本， 但是这些文本实际上不在文档树中。

## `display`

更改默认的显示方式。

### [`display:flex`](https://vue3js.cn/interview/css/flexbox.html#一、是什么)

只需要在想要进行`flex`布局的父元素上应用`display:flex`，所有直接子元素都将会按照`flex`进行布局。父元素上的`flex-direction`的初始值是`row`，这也是为什么能够一行排列。还会全部被拉伸到和最高的元素高度相同。

`flex`项还可以设置其他属性，这些属性可以改变`flex`项在`flex`布局中占用宽高的方式，允许伸缩来适应空间。

> 弹性盒子也有可以改变 `flex` 项的布局位置的功能，而不会影响到源顺序（即 `dom` 树里元素的顺序）。这也是传统布局方式很难做到的一点。

```CSS
button:first-child {
  order: 1;
}
```

- 所有 `flex` 项默认的 `order` 值是 0。

- `order` 值大的 `flex` 项比 `order` 值小的在显示顺序中更靠后。

- 相同 `order` 值的 `flex` 项按源顺序显示。所以假如你有四个元素，其 `order` 值分别是2，1，1和0，那么它们的显示顺序就分别是第四，第二，第三，和第一。

- 第三个元素显示在第二个后面是因为它们的 `order` 值一样，且第三个元素在源顺序中排在第二个后面。

### `display:grid`

`display: grid`的声明只创建了一个只有一列的网格，所以你的子项还是会像正常布局流那样从上而下一个接一个的排布。

```
grid-template-columns: 2fr 1fr 1fr
```

可以使用`fr`单位设置列，`1fr`表示一份，**注意：**`fr`单位分配的是*可用*空间而非*所有*空间，所以如果某一格包含的内容变多了，那么整个可用空间就会减少，可用空间是不包括那些已经确定被占用的空间的。

```
grid-gap: 20px;
```

定义行和列的间隙，除了`fr`的长度单位都可以用

```
grid-auto-rows: 100px;
```

相比于`grid-template-rows`，`template`只定义了定义的那几行该怎么布局，比如尺寸多大，但是超出部分的布局是由`auto`的信息决定的。

> 显式网格和隐式网格。显式网格是我们用`grid-template-columns` 或 `grid-template-rows` 属性创建的。而隐式网格则是当有内容被放到网格外（显示网格定义的行或者列以外的行列）时才会生成的。

![img](/assets/css/网格布局.png)

```
grid-auto-rows: minmax(100px, auto);
```

`minmax` 函数为一个行/列的尺寸设置了取值范围。比如设定为 `minmax(100px, auto)`，那么尺寸就至少为100像素，并且如果内容尺寸大于100像素则会根据内容自动调整。

## `position`定位

允许精准设置盒子中的盒子的位置

### **相对定位`relative`：**

如果对一个元素进行相对定位，它将出现在其所在的位置，可以通过设置垂直或水平位置，让这个元素”相对于“起点移动，在使用相对定位的时候，无论是否进行移动，元素仍然占据原来的空间，因此，移动元素会导致它覆盖其他框。

### **绝对定位`absolute`：**

定位是相对于最近的已定位祖先元素，如果元素没有已定位的父元素，那么它的位置相对于初始包含块，（可能是画布或者`HTML`）`absolute`定位使元素的位置与文档流无关，因此不占据空间。`absolute`定位的元素和其它元素重叠。这样可以用来设计弹出框 拖放等`ui`。

### **固定定位`fixed`：**

元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的也不会移动，`fixed`定位使得元素的位置与文档流无关，不占据空间，会和其它元素重叠。

### **粘性定位`sticky`：（相对定位和固定定位的混合体）**

元素先按照普通文档流定位，然后相当于该元素在流中的`bfc`和最近的块级祖先元素定位，而后，元素定位表现为在一个范围特定于之前是相对定位，之后是固定定位。

### **默认定位`static`**

元素出现在正常的流中

### **继承定位`inherit`**

规定应该从父元素继承`position`属性值

## `float`

应用`float`，如`left`能够让块级元素互相并排成一行。

`float`会脱离正常的文档布局流，并吸附到父容器的左边，在正常布局中位于该浮动元素之下的内容会围绕着浮动元素，填满右侧的空间。

## `link`和`@import`的区别

`link`属于`xhtml`标签，`@import`是`css`提供的

页面被加载的时候，`link`会同时被加载，而`@import`引用的`css`会等到页面被加载完再加载

`import`只在`ie5`以上才能识别`link`是`XTML`标签，无兼容问题

`link`方式的样式权重高于`@import`的权重

使用`dom`控制样式时候，使用`js`控制`dom`去改变样式只能使用`link`标签，因为`@import`不是`dom`可以控制的

## `em/px/rem`区别

`px`是绝对单位，页面按照精确像素展示

`em`相对单位，基准点是本元素或者父元素字体大小，优先级是本元素，接着是父元素。默认字体是16px，所以`1em`并非固定的值。同时为了方便换算`px`和`em`，需要在`css`的`body`选择器中声明`font-size=62.5%`，这样的话`1em`对应着`10px`。

> `em`：在 `font-size` 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 `width`

`rem`：相对单位，可理解为相对`html`根元素的字体大小来计算，`CSS3`新加的属性。

## `src`和`href`的区别

`src`指向外部资源的位置，指向的内容会嵌入到文档中当前标签所在的位置，在请求`src`资源时会将其指向的资源下载并应用到文档内。当浏览器解析到该元素的时候，会暂停其他资源的下载和处理，直到该资源加载编译执行完毕，所以一般的`js`脚本放在底部而不是头部。

`href`是指向网络资源所在位置的超链接，用来建立和当前元素或者文档的连接，当浏览器识别到它指向的文件的时候，就会并行下载资源，不会停止对当前文档的处理。

## 隐藏页面元素

`opacity:0` ：本质上是将元素的透明度将为0，就看起来隐藏了，但是依然占据空间且可以交互

`visibility:hidden` : 与上⼀个方法类似的效果，占据空间，但是不可以交互了 

`overflow:hidden` : 这个只隐藏元素溢出的部分，但是占据空间且不可交互

`display:none` : 这个是彻底隐藏了元素，元素从文档流中消失，既不占据空间也不交互，也不影响布局

`z-index:-9999` : 原理是将层级放到底部，这样就被覆盖了，看起来隐藏了

` transform: scale(0,0)` : 平⾯变换，将元素缩放为0，但是依然占据空间，但不可交互

#### z-index

只能影响设置了position值的元素

## 清除浮动

在非`IE`浏览器（如`Firefox`）下，当容器高度为`auto`，且容中仅有浮动（`float`为`left`或`right`）的元素，在这种情况下，容器的高度不能自动伸长以适应内容的高度，使得内容溢出到容器外面而影响（甚至破坏）布局的现象。这个现象叫浮动溢出，为了防止这个现象的出现而进行的CSS处理，就叫`CSS`清除浮动。

[本质是利用`clear`属性](https://segmentfault.com/a/1190000021201257)

**空`div`方法：**`<div style="clear:both;"></div>`

 **`clearfix` 方法：上文使用`.clearfix`类已经提到**

`clear`：指定一个元素是否必须移动到他之前的浮动元素的下面，`clear:left`表示设置这个属性的元素需要移动到具有`float：left`的元素的下面，`both`的话就是要移动到`left`和`right`的下面。使用`CSS`的`overflow`属性 本质是利用`BFC`

**给浮动元素的容器添加`overflow:hidden`;或`overflow:auto`;可以清除浮动，另外在 `IE6` 中还需要触发 `hasLayout` ，例如为父元素设置容器宽高或设置 `zoom:1`。**

当元素设置了`overflow`样式且值部位`visible`时，该元素就构建了⼀个`BFC`，`BFC`在计算高度时，内部浮动元素的高度也要计算在内，也就是说即使`BFC`区域内只有一个浮动元素，`BFC`的高度也不会发生塌缩，所以达到了清除浮动的目的。

**推荐**

 在网页主要布局时使用`:after`伪元素方法并作为主要清理浮动方式；在小模块如`ul`里使用`overflow:hidden`；如果本身就是浮动元素则可自动清除内部浮动，无需格外处理；正文中使用邻接元素清理之前的浮动。

 最后可以使用相对完美的`:after`伪元素方法清理浮动，文档结构更加清晰。

## BFC

`box:CSS`布局的对象和基本单位

`Formatting context`

页面中的一块渲染区域 有一套渲染规则 决定了子元素如何定位以及和其它元素的关系和相互作用。

`BFC`：块级格式化上下文 一个独立的渲染区域规定了内部块级盒子的布局 不影响区域外的。

### **`BFC`布局规则**

1. 内部的`Box`会在垂直方向，一个接一个地放置。
2. `Box`垂直方向的距离由`margin`决定。属于同一个`BFC`的两个相邻`Box`的`margin`会发生重叠
3. 每个元素的`margin box`的左边， 与包含块`border box`的左边相接触(对于从左往右的格式化，否则相反)。**即使存在浮动也是如此**。（这也就是说会发生重叠）
4. `BFC`的区域不会与`float box`重叠。（这也就是说能够防止重叠，设置未浮动元素为`bfc`）
5. `BFC`就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
6. 计算`BFC`的高度时，浮动元素也参与计算

触发条件：

根元素，即`HTML`元素

`position：fixed/absolute`

`float`不为`none`

`overflow`不为`visible`

`display`的值是`inline-block table-cell table-caption flex` **`flow-root`（在父级块使用，无副作用）**

因为`BFC`内部的元素和外部的元素绝对不会互相影响，因此， 当`BFC`外部存在浮动时，它不应该影响`BFC`内部`Box`的布局，**`BFC`会通过变窄，而不与浮动有重叠**。同样的，当`BFC`内部有浮动时，为了不影响外部元素的布局，`BFC`计算高度时会包括浮动的高度。避免`margin`重叠也是这样的一个道理。

应用：

清除浮动：为父元素创建`BFC`来包含浮动元素，使其不影响外部的布局

消除外边距合并：

## [盒子模型](https://vue3js.cn/interview/css/box.html#一、是什么)

CSS中广泛使用块级盒子和内联盒子（对应着**外部显示类型**）。

块级盒子：

- 块级盒子会在内联方向扩展直到占据父容器的宽度=>每个盒子会换行
- width和height有效
- 内边距 边框 外边距会将其他元素从当前盒子周围推开。

内联盒子：

- 不会在内联方向展开=>不会换行
- width和height无效
- 垂直方向的内边距 边框 外边距会被应用但是不会把其他内联盒子推开
- 水平方向的内边距 边框 外边距会被应用且会把其他内联盒子推开

**内部显示类型：**

决定盒子内部如何布局，默认是按照正常文档流布局（没有改变默认布局规则下的页面元素布局，会有块级盒子和内联盒子的特点以及外边距塌陷等问题）

可以设置display来改变盒子的外部显示类型。

display包括：

block:

inline:

flex:

grid:

inline-block:在内联和块之间提供了一个中间状态，既可以不切换到新行，又可以设定宽度和高度，padding、margin、border会推开其他元素。



CSS 盒模型由content（内容）、padding（内边距）、border（边框）、margin（外边距）组成。

> margin 不计入实际大小 —— 当然，它会影响盒子在页面所占空间，但是影响的是盒子外部空间。盒子的可见范围到边框为止 —— 不会延伸到margin。应用于元素的任何背景都将显示在内边距后面，设置的背景会在内容区和内边距区域显示，内边距通常用于将内容推离边框。



CSS盒子模型包括**IE盒子模型(box-size:border-box)**和**标准的W3C盒子模型（box-sizing:content-box）**。默认浏览器会使用标准模型，可以设置box-sizing:border-box实现

> Internet Explorer默认使用替代盒模型，没有可用的机制来切换。（译者注：IE8+ 支持使用`box-sizing` 进行切换 ）



**标准盒模型**：盒子总宽度 = width + padding + border;(实际盒子)

元素的width值即为盒模型中content的宽度值，也就是说如下例子，width:200px，表示展现的盒子content的宽度就是200px，再加上padding:20px，实际的盒子大小是240px；

```HTML
<style>
  .box {
    width: 200px;
    height: 100px;
    padding: 20px;
  }
</style>
<div class="box">
  盒子模型
</div>
```



**IE盒模型**：盒子总宽度 = width;（实际盒子）

元素的width值即为盒模型中content+padding+border的宽度值，也就是说如下例子，width:200px，表示展现的盒子content的宽度是200px-border的宽度-padding的宽度，实际的盒子大小是200px；

```HTML
<style>
  .box {
    width: 200px;
    height: 100px;
    padding: 20px;
    box-sizing: border-box;
  }
</style>
<div class="box">
  盒子模型
</div>
```

## 行内元素，块元素

行内元素：行内元素只占据它对应标签的边框所包含的空间

常见的行内元素由a b span img strong sub button input label select

块元素：占据父元素容器的整个宽度

常见的块级元素由div ul ol li h1 p

**二者区别：**

格式上 行内元素不会以新行开始 块级元素会新起一行

内容上 默认情况下行内元素只能包含文本和其他的行内元素，而块级元素可以包含行内元素和其他块级元素

属性上 行内元素设置width无效 height无效 但是可以设置line-height 设置margin padding的上下不会对其他元素产生影响。

## CSS动画

**transition**属性是一个简写属性，用于设置四个过渡属性

| **值**                     | **描述**                        |
| -------------------------- | ------------------------------- |
| transition-property        | 规定设置过渡效果的CSS属性的名称 |
| transition-duration        | 规定完成过渡效果需要的时间      |
| transition-timing-function | 规定速度效果的速度曲线          |
| transition-delay           | 定义过渡效果何时开始            |

1. transition需要事件触发，所以没法在⽹⻚加载时⾃动发⽣。
2. transition是⼀次性的，不能重复发⽣，除⾮⼀再触发。
3. transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。
4. ⼀条transition规则，只能定义⼀个属性的变化，不能涉及多个属性。

**animation**

| **值**                    | **描述**                                 |
| ------------------------- | ---------------------------------------- |
| animation-name            | 规定需要绑定到选择器的 keyframe 名称。   |
| animation-duration        | 规定完成动画所花费的时间，以秒或毫秒计。 |
| animation-timing-function | 规定动画的速度曲线。                     |
| animation-delay           | 规定在动画开始之前的延迟。               |
| animation-fill-mode       | 规定动画结束时保持的状态。               |
| animation-iteration-count | 规定动画应该播放的次数。                 |
| animation-direction       | 规定是否应该轮流反向播放动画。           |

## 重绘和重排

1. 浏览器把获取到的HTML代码解析成1个DOM树，HTML中的每个标签都是DOM树中的1个节点，根节点就是我们常⽤的document对象。DOM树⾥包含了所有HTML标签，包括display:none;隐藏的，还有⽤JS动态添加的元素等。
2. 浏览器把所有样式(⽤户定义的CSS和⽤户代理)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，⽐如IE会去掉-moz开头的样式，⽽FF会去掉_开头的样式。
3. DOM Tree 和样式结构体组合后构建render tree, render tree类似于DOM tree，但区别很⼤，render tree能识别样式，render tree中每个NODE都有⾃⼰的style，⽽且render tree不包含隐藏的节点 (⽐如display:none的节点，还有head节点)，因为这些节点不会⽤于呈现，⽽且不会影响呈现的，所以就不会包含到 render tree中。注意visibility:hidden隐藏的元素还是会包含到 render tree中的，因为visibility:hidden 会影响布局(layout)，会占有空间。根据CSS2的标准，render tree中的每个节点都称为Box(Box dimensions)，理解⻚⾯元素为⼀个具有填充、边距、边框和位置的盒⼦。

**重绘**：DOM元素的属性发生变化时，浏览器会通知render重新描绘相应的元素，此过程称为重绘

**重排**：重排是指某些元素变化涉及元素布局，浏览器抛弃原有属性，重新计算的过程。

**回流**：重排好的结果传递给render以重新描绘页面元素的过程

影响因素：添加或者删除可见的DOM元素，元素位置改变，尺寸改变，内容改变引起的计算值宽度和高度改变，页面渲染初始化，浏览器窗口尺寸改变，

优化：DOM的多个读操作或者多个写操作放在一起 不要两个读操作之间加入写操作

如果某个样式是通过重排得到的 最好缓存结果避免下一次使用的时候重新排列。

不要⼀条条地改变样式，⽽要通过改变class，或者csstext属性，⼀次性地改变样式。

尽量使⽤离线DOM，⽽不是真实的⽹⾯DOM，来改变元素样式。⽐如，使⽤ cloneNode() ⽅法，在克隆的节点上进⾏操作，然后再⽤克隆的节点替换原始节点。

先将元素设为display: none（需要1次重排和重绘），然后对这个节点进⾏100次操作，最后再恢复显示（需要1次重排和重绘）。这样⼀来，你就⽤两次重新渲染，取代了可能⾼达100次的重新渲染。

position属性为absolute或fixed的元素，重排的开销会⽐较⼩，因为不⽤考虑它对其他元素的影响。

只在必要的时候，才将元素的display属性为可⻅，因为不可⻅的元素不影响重排和重绘。另外，visibility: hidden的元素只对重绘有影响，不影响重排。

使⽤虚拟DOM的脚本库，⽐如Vue等。

## margin外边距折叠

 多个相邻（兄弟或者⽗⼦关系）普通流的块元素垂直⽅向marigin会重叠

 折叠边距计算：

 两个相邻的外边距都是正数时，折叠结果是它们两者之间较⼤的值。 两个相邻的外边距都是负数

 时，折叠结果是两者绝对值的较⼤值。 两个外边距⼀正⼀负时，折叠结果是两者的相加的和。

 防⽌外边距重叠解决⽅案：

1. 外层元素padding代替
2. 外层元素 overflow:hidden;
3. 内层元素绝对定位 postion:absolute:
4. 内层元素 加float:left;或display:inline-block;
5. 内层元素padding:1px;
6. 内层元素透明边框 border:1px solid transparent;

## 响应式设计

响应式web设计不是单独的技术，是描绘web设计的一种方式，或者一种最佳时间的一个词，用来建立可以响应查看内容的设备的样式的一个词。

### 媒介查询

媒体查询，以及样式改变时的点，被叫做*断点*（breakpoints）。

使用 `@media` [at-rule](https://developer.mozilla.org/zh-CN/docs/Web/CSS/At-rule) 根据媒体查询的结果有条件地应用样式表的一部分。 使用 `@import` 有条件地应用整个样式表。

> 可用于基于一个或多个媒体查询的结果来应用样式表的一部分。 使用它，您可以指定一个媒体查询和一个CSS块，当且仅当该媒体查询与正在使用其内容的设备匹配时，该CSS块才能应用于该文档。

### 响应式图像

使用了`<picture>`元素和`<img>` `srcset`和`sizes` 特性，你可以提供附带着“提示”（描述图像最适合的屏幕尺寸和分辨率的元数据）的多种尺寸，浏览器将会选择对设备最合适的图像，以确保用户下载尺寸适合他们使用的设备的图像。

**srcset**定义了我们允许浏览器选择的图像集，以及每个图像的大小。在每个逗号之前，我们写：

1. 一个**文件名** (`elva-fairy-480w.jpg`.)
2. 一个空格
3. **图像的固有宽度**（以像素为单位）（480w）——注意到这里使用`w`单位，而不是你预计的`px`。这是图像的真实大小，可以通过检查你电脑上的图片文件找到（例如，在Mac上，你可以在Finder上选择这个图像，然后按 Cmd + I 来显示信息）。

`**sizes**`定义了一组媒体条件（例如屏幕宽度）并且指明当某些媒体条件为真时，什么样的图片尺寸是最佳选择。在这种情况下，在每个逗号之前：

1. 一个**媒体条件**（`(max-width:480px)`）媒体条件描述了屏幕可能处于的状态。即“当可视窗口的宽度是480像素或更少”。
2. 一个空格
3. 当媒体条件为真时，图像将填充的**槽的宽度**（`440px`）

```HTML
<img srcset="elva-fairy-320w.jpg 320w,
             elva-fairy-480w.jpg 480w,
             elva-fairy-800w.jpg 800w"
     sizes="(max-width: 320px) 280px,
            (max-width: 480px) 440px,
            800px"
     src="elva-fairy-800w.jpg" alt="Elva dressed as a fairy">
```

### 使用视口单位实现响应式排版

视口单位vw，1vw等于视口宽度的百分之一

#### 视口元标签

```HTML
<meta name="viewport" content="width=device-width,initial-scale=1">
```

- `initial-scale`：设定了页面的初始缩放，我们设定为1。

- `height`：特别为视口设定一个高度。

- `minimum-scale`：设定最小缩放级别。

- `maximum-scale`：设定最大缩放级别。

- `user-scalable`：如果设为`no`的话阻止缩放。

你应该避免使用`minimum-scale`、`maximum-scale`，尤其是将`user-scalable`设为`no`。用户应该有权力尽可能大或小地进行缩放，阻止这种做法会引起访问性问题。

### 视差滚动

#### background-attachment

```CSS
/* 关键 属性值 */
/* 关于视口：浏览器窗口 */
background-attachment: scroll;  // 背景先相对于视口固定，后续相对元素固定
background-attachment: fixed;  // 背景相对于视口固定，元素滚动背景不随着滚动
background-attachment: local;  // 背景相对于元素内容固定，元素滚动背景跟着滚动
```

#### 多背景图支持

使用逗号分隔来为每一张背景指定不同的attachment属性值